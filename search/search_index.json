{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":""},{"location":"#what-is-this-package","title":"What is this package?","text":"<p>CSharp.Made.Functional is a collection of tools that can assist you in writing code that follows a  functional style while still using the C# language. There are some abstractions in this project  that will simplify functional programming in C#.</p>"},{"location":"#who-is-it-for","title":"Who is it for?","text":"<p>This package is designed for those who prefer to use functional style programming and want to  be able to incorporate some of the functional modelling principals into code that you work on.</p>"},{"location":"#why-did-you-create-this","title":"Why did you create this?","text":"<p>After reading Domain Modeling Made Functional  by Scott Wlaschin, I became more convinced that Railway-Oriented Programming  could help me write better code. As a C# web developer, I kept wishing that C# had some of the same ideas as F#  when it comes to the type system, especially types like Result and Option. This desire led me to create this  package in a way that I feel is easy to use and follows many of the naming conventions from F#.</p>"},{"location":"#does-it-work-with-blazor","title":"Does it work with Blazor?","text":"<p>Yes! One of my key needs for a functional library was one with no dependencies that could also be used in  Blazor WebAssembly projects. This project was developed using .NET 6 and I haven't found any limitations  to where it can be used yet.</p>"},{"location":"Examples/","title":"Examples","text":""},{"location":"Examples/#option","title":"Option","text":"<p>The Option type represents the concept that an item may or may not exist. In some ways C# already does this with the idea of the null value. However, in previous .NET and C# versions, objects could still be null even if their type signature indicated that they were a real, valid object. External packages may still have this issue, but internally you can force your code to obey the nullable rules using the Nullable directive in .NET 6 and later.</p> ScratchPad.csproj<pre><code>&lt;Nullable&gt;enable&lt;/Nullable&gt;\n</code></pre> <p>The following example shows how previous versions of .NET and C# would allow possible null returns. Using <code>FirstOrDefault</code> can produce a null value.</p> Valid or null...?<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ScratchPad;\n\npublic record TodoItem(string Title, bool Completed);\n\npublic static class Program\n{\n    public static List&lt;TodoItem&gt; TodoItems =&gt;\n        new()\n        {\n            new(\"Use CSharp.Made.Functional\", false),\n            new(\"Read the Docs\", true)\n        };\n\n\n    // Hides its true return type which should be 'TodoItem?'\n    public static TodoItem FindTodoItem(string title)\n    {\n\n        var todoItem =\n            TodoItems\n                .Where(todo =&gt; todo.Title.Contains(title))\n                .FirstOrDefault();\n\n        return todoItem;\n    }\n\n    public static void Main()\n    {\n        TodoItem todoItem = FindTodoItem(\"Title Which Doesn't Exist\");\n\n        // What does this print?\n        Console.WriteLine(todoItem.Title);\n    }\n}\n</code></pre>"},{"location":"Examples/#optional","title":"Optional","text":"<p>What if we could make the return type more explicit, beyond just changing the return type to <code>TodoItem?</code> for the <code>FindTodoItem</code> method? Shown in the example below, the <code>Option</code> type helps to declare that the return type might not exist. We can use the <code>Optional</code> extension to wrap values which may be null. When a value does not exist, it is represented by <code>None</code>. If a value exists, it is represented by <code>Some</code>.</p> <p>There are ways to get the internal value of the Option and those will be described in later examples. Looking at the previous example again, let's use the Optional extension method to improve the function signature.</p> Program.cs<pre><code>using System.Collections.Generic;\nusing System.Linq;\nusing Functional;\nusing static Functional.Prelude;\n\nnamespace ScratchPad;\n\npublic record TodoItem(string Title, bool Completed);\n\npublic static class Program\n{\n    public static List&lt;TodoItem&gt; TodoItems =&gt;\n        new()\n        {\n            new(\"Use CSharp.Made.Functional\", false),\n            new(\"Read the Docs\", true)\n        };\n\n\n    // Honest function signature which indicates optional value.\n    public static Option&lt;TodoItem&gt; TryFindTodoItem(string title) =&gt;\n        TodoItems\n            .Where(todo =&gt; todo.Title.Contains(title))\n            .FirstOrDefault()\n            .Optional();\n\n    public static void Main()\n    {\n        Option&lt;TodoItem&gt; todoItem = TryFindTodoItem(\"Title Which Doesn't Exist\");\n\n        // Ok, but how do we print the title now?\n    }\n}\n</code></pre>"},{"location":"Examples/#some-and-none","title":"Some and None","text":"<p>To create a <code>Some</code> or <code>None</code> directly, without using the <code>Optional</code> extension, the <code>Prelude</code> class provides helpers for this.</p> Program.cs<pre><code>using System;\nusing Functional;\nusing static Functional.Prelude;\n\nnamespace ScratchPad;\n\npublic static class Program\n{\n    public static void Main()\n    {\n        var someMessage =\n            // Type is inferred to be string.\n            Some(\"Hello, world\")\n                .Reduce(\"Won't be me!\");\n\n        var noneMessage =\n            // Type can't be inferred, so one must be provided.\n            None&lt;string&gt;()\n                .Reduce(\"It was None\");\n\n        // Prints \"Hello, world\"\n        Console.WriteLine(someMessage);\n\n        // Prints \"It was None\"\n        Console.WriteLine(noneMessage);\n    }\n}\n</code></pre>"},{"location":"Examples/#map-filter-and-reduce","title":"Map, Filter, and Reduce","text":"<p>In the example showing the <code>Optional</code> extension, we improved the function  signature of the <code>TryFindTodoItem</code> method. Let's go a step further and find  out how we can actually get the value of out an <code>Option</code> type using  <code>Map</code>, <code>Filter</code>, and <code>Reduce</code>. The <code>Map</code> method performs mapping on the  internal type that is wrapped by the <code>Option</code>. In the example, our internal  type is a <code>TodoItem</code>. Below we use it to get the title using <code>Map</code> in the case  that the <code>Option</code> is a <code>Some</code>. How do we represent a title if the <code>Option</code> is <code>None</code>?  This is where <code>Reduce</code> comes in. We can supply an alternate value directly,  or we can supply a function that returns an alternate value.  The function approach is useful in cases where getting an alternate value might be computationally expensive. Finally, <code>Filter</code> is used to convert a  <code>Some</code> to a <code>None</code> when the filter criteria evaluates to true.</p> Program.cs<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Functional;\nusing static Functional.Prelude;\n\nnamespace ScratchPad;\n\npublic record TodoItem(string Title, bool Completed);\n\npublic static class Program\n{\n    public static List&lt;TodoItem&gt; TodoItems =&gt;\n        new()\n        {\n            new(\"Use CSharp.Made.Functional\", false),\n            new(\"Read the Docs\", true)\n        };\n\n    public static Option&lt;TodoItem&gt; TryFindTodoItem(string title) =&gt;\n        TodoItems\n            .Where(todo =&gt; todo.Title.Contains(title))\n            .FirstOrDefault()\n            .Optional();\n\n    public static void Main()\n    {\n        string readTheDocs =\n            TryFindTodoItem(\"Read\")\n                .Map(todoItem =&gt; todoItem.Title)\n                .Reduce(\"Not Found\");\n\n        string notFound =\n            TryFindTodoItem(\"Read\")\n                .Filter(todoItem =&gt; todoItem.Completed == false)\n                .Map(todoItem =&gt; todoItem.Title)\n                .Reduce(() =&gt; \"Not Found\");\n\n\n        // Prints \"Read the Docs\" because the item exists.\n        Console.WriteLine(readTheDocs);\n\n        // Prints \"Not Found\" because the TodoItem is Completed, so it is filtered out.\n        Console.WriteLine(notFound);\n    }\n}\n</code></pre>"},{"location":"Examples/#option-match","title":"Option Match","text":"<p>Sometimes <code>Map</code> and <code>Reduce</code> may not feel like the right solution to a problem.  In those cases it may feel more natural to reach for the <code>Match</code> method.  <code>Match</code> expects two mapping functions to be provided to extract the value  of the <code>Option</code>. See below for an alternate approach using <code>Match</code>.</p> Program.cs<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Functional;\nusing static Functional.Prelude;\n\nnamespace ScratchPad;\n\npublic record TodoItem(string Title, bool Completed);\n\npublic static class Program\n{\n    public static List&lt;TodoItem&gt; TodoItems =&gt;\n        new()\n        {\n            new(\"Use CSharp.Made.Functional\", false),\n            new(\"Read the Docs\", true)\n        };\n\n    public static Option&lt;TodoItem&gt; TryFindTodoItem(string title) =&gt;\n        TodoItems\n            .Where(todo =&gt; todo.Title.Contains(title))\n            .FirstOrDefault()\n            .Optional();\n\n    public static void Main()\n    {\n        string readTheDocs =\n            TryFindTodoItem(\"Read\")\n                .Match(\n                    todoItem =&gt; todoItem.Title,\n                    () =&gt; \"Not Found\");\n\n        string notFound =\n            TryFindTodoItem(\"Read\")\n                .Filter(todoItem =&gt; todoItem.Completed == false)\n                .Match(\n                    todoItem =&gt; todoItem.Title,\n                    () =&gt; \"Not Found\");\n\n        // Prints \"Read the Docs\" because the item exists.\n        Console.WriteLine(readTheDocs);\n\n        // Prints \"Not Found\" because the TodoItem is Completed, so it is filtered out.\n        Console.WriteLine(notFound);\n    }\n}\n</code></pre>"},{"location":"Examples/#option-bind","title":"Option Bind","text":"<p>Since the <code>Map</code> function performs an action on an <code>Option</code> only when it  is <code>Some</code>, the return type of <code>Map</code> is still <code>Option</code>. This means that  inside the mapping operation, we usually want to do transformations  that don't result in another <code>Option</code> type, otherwise we would end up  with <code>Option&lt;Option&lt;T&gt;&gt;</code>. This is the reason for the <code>Bind</code> function.  We can use <code>Bind</code> instead of <code>Map</code>.</p> Program.cs<pre><code>using System;\nusing Functional;\nusing static Functional.Prelude;\n\nnamespace ScratchPad;\n\npublic static class Program\n{\n\n    // This could be some database call which may result in None\n    public static Option&lt;string&gt; TryFindString(string input) =&gt;\n        Some(input);\n\n    // Trivial example, but shows how mapping to an option requires Bind.\n    public static Option&lt;string&gt; NoEmptyStringsAllowed(string input) =&gt;\n        string.IsNullOrWhiteSpace(input) switch\n        {\n            true =&gt; None&lt;string&gt;(),\n            false =&gt; Some(input),\n        };\n\n    public static void Main()\n    {\n        var toPrint =\n            TryFindString(\"Hello, World!\")\n                .Bind(NoEmptyStringsAllowed)\n                .Reduce(\"Not Found\");\n\n        // Prints \"Hello, World!\"\n        Console.WriteLine(toPrint);\n    }\n}\n</code></pre>"},{"location":"Examples/#option-effect","title":"Option Effect","text":"<p>If we just want to perform some <code>Action</code> which is somewhat of a side-effect,  we can use the <code>Effect</code> method. Using the previous example, we can  significantly simplify the code if we just want to do a single  <code>Console.WriteLine</code>. We also don't have to print anything if the  <code>TodoItem</code> is <code>None</code>.</p> Program.cs<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Functional;\nusing static Functional.Prelude;\n\nnamespace ScratchPad;\n\npublic record TodoItem(string Title, bool Completed);\n\npublic static class Program\n{\n    public static List&lt;TodoItem&gt; TodoItems =&gt;\n        new()\n        {\n            new(\"Use CSharp.Made.Functional\", false),\n            new(\"Read the Docs\", true)\n        };\n\n    public static Option&lt;TodoItem&gt; TryFindTodoItem(string title) =&gt;\n        TodoItems\n            .Where(todo =&gt; todo.Title.Contains(title))\n            .FirstOrDefault()\n            .Optional();\n\n    public static void Main() =&gt;\n        TryFindTodoItem(\"Read\")\n            .Effect(\n                todoItem =&gt; Console.WriteLine(todoItem.Title),\n                () =&gt; { /* We don't have to print anything actually... */ });\n}\n</code></pre>"},{"location":"Examples/#option-effectsome-and-effectnone","title":"Option EffectSome and EffectNone","text":"<p>If we only want to perform an effect when an <code>Option</code> is <code>Some</code> or  when it's <code>None</code>, we can use the <code>EffectSome</code> and <code>EffectNone</code> methods  which will consume the <code>Option</code>.</p> Program.cs<pre><code>namespace ScratchPad;\n\nusing Functional;\nusing static Functional.Prelude;\nusing System;\n\npublic static class Program\n{\n    public static void Main()\n    {\n        // This will print \"value\" to the console.\n        Some(\"value\")\n            .EffectSome(value =&gt; Console.WriteLine(value));\n\n        // This will do nothing since the input value was a None.\n        None&lt;string&gt;()\n            .EffectSome(value =&gt; Console.WriteLine(value));\n\n        // This will do nothing since the input is a Some.\n        Some(\"value\")\n            .EffectNone(() =&gt; Console.WriteLine(\"won't print\"));\n\n        // This will print \"no value\" since the input was None.\n        None&lt;string&gt;()\n            .EffectNone(() =&gt; Console.WriteLine(\"no value\"));\n    }\n}\n</code></pre>"},{"location":"Examples/#option-tap-tapsome-and-tapnone","title":"Option Tap, TapSome and TapNone","text":"<p>If we want to <code>Tap</code> into the <code>Option</code> and perform some effect without  consuming the value, we can use <code>Tap</code>, <code>TapSome</code>, and <code>TapNone</code>.  With <code>Tap</code>, some kind of action must be provided for both  the <code>Some</code> and <code>None</code> cases.</p> <p>For <code>TapSome</code> and <code>TapNone</code>, one or more actions can be provided  to occur when the <code>Option</code> meets that criteria. This will allow us  to only perform actions when the value is <code>Some</code> or <code>None</code> for instance.</p> Program.cs<pre><code>namespace ScratchPad;\n\nusing Functional;\nusing static Functional.Prelude;\nusing System;\n\npublic static class Program\n{\n    public static void Main()\n    {\n        // Actions can be performed when some and none.\n        Some(\"value\")\n            .Tap(some =&gt; Console.WriteLine(some), () =&gt; Console.WriteLine(\"none\"))\n            // The Option is not consumed so we can still use it afterwards.\n            .Map(some =&gt; some + \"!\");\n\n        // We can do multiple things when the value is Some with a TapSome.\n        string? temp = null;\n        Some(\"value\")\n            .TapSome(\n                value =&gt; Console.WriteLine(value),\n                value =&gt; temp = value);\n\n        // Nothing happens here since the value is a None.\n        None&lt;string&gt;()\n            .TapSome(value =&gt; Console.WriteLine(value));\n    }\n}\n</code></pre>"},{"location":"Examples/#option-unwrap","title":"Option Unwrap","text":"<p>If we need to get the value out of an <code>Option</code> for some reason and it's  impractical to use <code>Match</code>, <code>Map</code>, <code>Tap</code>, or <code>Effect</code>, we can <code>Unwrap</code> the  value to get its inner contents. It's vital to check to see if the <code>Option</code> is <code>Some</code> before doing this,  otherwise it will throw an exception!</p> Program.cs<pre><code>namespace ScratchPad;\n\nusing Functional;\nusing static Functional.Prelude;\nusing System;\n\npublic static class Program\n{\n    public static void Main()\n    {\n        // This will unwrap fine because the value is some.\n        string value = Some(\"value\").Unwrap();\n\n        // This will throw an exception because the value is none.\n        string never = None&lt;string&gt;().Unwrap();\n\n        // To do this safely, we need to always check the Option first!\n        var option = None&lt;string&gt;();\n        if (option.IsSome)\n        {\n            value = option.Unwrap();\n        }\n    }\n}\n</code></pre>"},{"location":"Examples/#async-options","title":"Async Options","text":"<p>Asynchronous support is also provided in this library. The <code>Optional</code> extension  also works on <code>Task&lt;T&gt;</code> where <code>T</code> is some type. This means that <code>Task&lt;T&gt;</code>  or <code>Task&lt;T?&gt;</code> becomes <code>Task&lt;Option&lt;T&gt;&gt;</code>.</p> <p>Async Option Methods:</p> <ul> <li><code>FilterAsync</code></li> <li><code>MapAsync</code></li> <li><code>ReduceAsync</code></li> <li><code>MatchAsync</code></li> <li><code>BindAsync</code></li> <li><code>EffectAsync</code></li> <li><code>EffectSomeAsync</code></li> <li><code>EffectNoneAsync</code></li> <li><code>TapAsync</code></li> <li><code>TapSomeAsync</code></li> <li><code>TapNoneAsync</code></li> <li><code>UnwrapAsync</code></li> <li><code>UnwrapErrorAsync</code></li> </ul> Program.cs<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Functional;\nusing static Functional.Prelude;\n\nnamespace ScratchPad;\n\npublic record TodoItem(string Title, bool Completed);\n\npublic static class Program\n{\n    public static List&lt;TodoItem&gt; TodoItems =&gt;\n        new()\n        {\n            new(\"Use CSharp.Made.Functional\", false),\n            new(\"Read the Docs\", true)\n        };\n\n    // AsAsync is an extension method to wrap an item with a Task.\n    public static async Task&lt;Option&lt;TodoItem&gt;&gt; TryFindTodoItem(string title) =&gt;\n        await TodoItems\n            .Where(todo =&gt; todo.Title.Contains(title))\n            .FirstOrDefault()\n            .Async()\n            .Optional();\n\n    public static async Task Main()\n    {\n        string readTheDocs =\n            await TryFindTodoItem(\"Read\")\n                .MapAsync(todoItem =&gt; todoItem.Title)\n                .ReduceAsync(\"Not Found\");\n\n        string notFound =\n            await TryFindTodoItem(\"Read\")\n                .FilterAsync(todoItem =&gt; todoItem.Completed == false)\n                .MapAsync(todoItem =&gt; todoItem.Title)\n                .ReduceAsync(\"Not Found\");\n\n\n        // Prints \"Read the Docs\" because the item exists.\n        Console.WriteLine(readTheDocs);\n\n        // Prints \"Not Found\" because the TodoItem is Completed, so it is filtered out.\n        Console.WriteLine(notFound);\n    }\n}\n</code></pre>"},{"location":"Examples/#union","title":"Union","text":"<p>The Discriminated Union represents a type which may have multiple sub-types  called variants. This is a very powerful concept which can be used to model  many different real-world relationships in programming. Here is an example  of what this looks like in F#. Using the built-in <code>match</code> expression in F#,  we have a compile-time exhaustive match expression.</p> Program.fs<pre><code>type Animal =\n    | Cat\n    | Dog\n    | Bird\n\nlet GetMysteryAnimal () : Animal = Bird\n\nlet MakeAnimalNoises () : string =\n    match GetMysteryAnimal() with\n    | Cat -&gt; \"Meow\"\n    | Dog -&gt; \"Ruff\"\n    | Bird -&gt; \"Tweet\"\n</code></pre> <p>In C#, this concept is often modeled using inheritance. This also means that  we can't predict every possible type which could inherit from the original  <code>Animal</code> class. So, the switch expression is as close to the F# <code>match</code> as  we can get. Unfortunately for us, we always have one last annoying discard case.  At best, we have a case which is never used, but is required for the code to compile.  At worst, we probably have undetected logic bugs. For instance, when  another variant is added as an <code>Animal</code> type, which should have a real  animal sound, it will return \"What Goes Here\" instead of a real value.  We are sadly never alerted by the compiler that we haven't handled the new  variant. Problematic, indeed.</p> Program.cs<pre><code>namespace ScratchPad;\n\npublic class Animal { }\npublic class Bird : Animal { }\npublic class Dog : Animal { }\npublic class Cat : Animal { }\n\npublic static class Program\n{\n    public static Animal GetMysteryAnimal() =&gt;\n        new Bird();\n\n    public static string MakeAnimalNoises() =&gt;\n        GetMysteryAnimal() switch\n        {\n            Bird =&gt; \"Tweet\",\n            Dog =&gt; \"Ruff\",\n            Cat =&gt; \"Meow\",\n            _ =&gt; \"What Goes Here?\",\n        };\n\n    public static void Main() { }\n}\n</code></pre>"},{"location":"Examples/#create-your-own-union","title":"Create your own Union","text":"<p>What if we could have compile-time type checking that ensured we handled every  variant? It is possible using the <code>Union</code> type. In fact, <code>Option</code> and <code>Result</code>  use the <code>Union</code> type underneath. In order to ensure strong compile-time variant  checking, there are different names for each <code>Union</code> type to handle different  numbers of variants. For example, <code>Option</code> uses the regular <code>Union</code> type because  it has two variants, <code>Some</code> and <code>None</code>. In our animal example, however, we have 3 variants that we care about. So in this case, we need to use <code>Union3</code>. The  following list shows the maximum number of variants that are currently supported  by this library. I would posit that if more variants are needed, it's possible  that another data modeling strategy may be a better fit. Remember, every variant must be handled, so for <code>Union9</code> this means that every match expression must  have 9 different functions in order to handle every possible case.</p> <p>Currently supported Unions:</p> <ul> <li><code>Union</code></li> <li><code>Union3</code></li> <li><code>Union4</code></li> <li><code>Union5</code></li> <li><code>Union6</code></li> <li><code>Union7</code></li> <li><code>Union8</code></li> <li><code>Union9</code></li> </ul> <p>This implementation is a lot more verbose than the F# version, which is why C#  needs built-in support for discriminated unions. However, it does accomplish  the same goal. It is recommended that you seal any <code>Union</code> classes that you  create in order to make sure that other classes cannot inherit from it.  There must be a public constructor for each variant and no other constructors.  It's also recommended that you implement the <code>Match</code> method as shown below  to access the internal <code>Union</code> contents and use the underlying <code>Union.Match</code> method. It is also recommended to create static factory methods named after  each variant. This will simplify the way that <code>Animal</code> instances are created.</p> Program.cs<pre><code>using System;\nusing Functional;\nusing static Functional.Prelude;\nnamespace ScratchPad;\n\npublic sealed class Animal\n{\n    private Union3&lt;Bird, Dog, Cat&gt; contents;\n    public Animal(Bird bird) =&gt; contents = new(bird);\n    public Animal(Cat cat) =&gt; contents = new(cat);\n    public Animal(Dog dog) =&gt; contents = new(dog);\n\n    public T Match&lt;T&gt;(Func&lt;Bird, T&gt; whenBird, Func&lt;Dog, T&gt; whenDog, Func&lt;Cat, T&gt; whenCat) =&gt;\n        contents\n            .Match(whenBird, whenDog, whenCat);\n\n    public static Animal Cat() =&gt; new(new Cat());\n    public static Animal Dog() =&gt; new(new Dog());\n    public static Animal Bird() =&gt; new(new Bird());\n}\npublic record Bird()\n{\n    public string Tweet =&gt; \"Tweet\";\n}\npublic record Cat()\n{\n    public string Meow =&gt; \"Meow\";\n}\npublic record Dog()\n{\n    public string Bark =&gt; \"Ruff\";\n}\n\n\npublic static class Program\n{\n    public static Animal GetMysteryAnimal() =&gt;\n        Animal.Bird();\n\n    public static string MakeAnimalNoises() =&gt;\n        GetMysteryAnimal()\n            .Match(\n                bird =&gt; bird.Tweet,\n                dog =&gt; dog.Bark,\n                cat =&gt; cat.Meow);\n\n    public static void Main()\n    {\n        // Prints \"Tweet\"\n        Console.WriteLine(MakeAnimalNoises());\n    }\n}\n</code></pre>"},{"location":"Examples/#errors-instead-of-exceptions","title":"Errors instead of Exceptions","text":"<p>C# makes heavy use of exceptions, but not all behavior is truly exceptional.  For instance, if an item can't be found in a database, should we throw a  <code>NotFoundException</code> and cause the server to crash if it's not handled?  Instead, we can use the <code>Union</code> type to create an error type which can be used  to model errors that could happen during processing. Here is an example of  an error which could happen when performing database operations with an  <code>Animal</code> object. In a web application, instead of returning a string,  we could match the type of error and return an <code>HttpResponse</code> related to  that type of error as an example.</p> Program.cs<pre><code>using System;\nusing Functional;\nusing static Functional.Prelude;\nnamespace ScratchPad;\n\npublic sealed class AnimalError\n{\n    private Union3&lt;NotFound, Invalid, Unhandled&gt; contents;\n    public AnimalError(NotFound notFound) =&gt; contents = new(notFound);\n    public AnimalError(Invalid invalid) =&gt; contents = new(invalid);\n    public AnimalError(Unhandled unhandled) =&gt; contents = new(unhandled);\n\n    public T Match&lt;T&gt;(Func&lt;NotFound, T&gt; notFound, Func&lt;Invalid, T&gt; invalid, Func&lt;Unhandled, T&gt; unhandled) =&gt;\n        contents\n            .Match(notFound, invalid, unhandled);\n\n    public static AnimalError NotFound() =&gt; new(new NotFound());\n    public static AnimalError Invalid() =&gt; new(new Invalid());\n    public static AnimalError Unhandled() =&gt; new(new Unhandled());\n}\n\n// Like a 404\npublic record NotFound();\n\n// Like a 400\npublic record Invalid();\n\n// Like a 500\npublic record Unhandled();\n\n\npublic static class Program\n{\n    public static AnimalError DatabaseOperationWhichErrors() =&gt;\n        AnimalError.NotFound();\n\n    public static string CreateNewAnimal() =&gt;\n        DatabaseOperationWhichErrors()\n            .Match(\n                notFound =&gt; \"Animal was not found\",\n                invalid =&gt; \"The animal was invalid\",\n                unhandled =&gt; \"Something unexpected happened\");\n\n    public static void Main()\n    {\n        // Prints \"Animal was not found\"\n        Console.WriteLine(CreateNewAnimal());\n    }\n}\n</code></pre>"},{"location":"Examples/#built-in-methods","title":"Built-in Methods","text":"<p>All of the <code>Union</code> variants have <code>Effect</code> and <code>Match</code> built-in. This means that if you create a custom <code>Union</code> type, you can use the inner <code>Union</code> built-in  methods to expose public versions on your custom <code>Union</code> type. An example of  this is shown in the previous <code>Animal</code> example with the <code>Match</code> method.</p>"},{"location":"Examples/#result","title":"Result","text":"<p>In the previous example, the database operation only ever returned an error.  But in real life, database operations would produce a good result sometimes,  and an error result other times. We could roughly categorize these as successes  and failures. In trying to keep with the same syntax as F#, this library calls  successes <code>Ok</code> and failures <code>Error</code>. This is what a <code>Result</code> looks like in F#.</p> Program.fs<pre><code>open System\n\ntype CustomError = { message: string }\n\nlet NoEmptyStrings (input: string) : Result&lt;string, CustomError&gt; =\n    input\n    |&gt; String.IsNullOrWhiteSpace\n    |&gt; function\n        | true -&gt; Error { message = \"Empty strings are not allowed.\" }\n        | false -&gt; Ok input\n</code></pre> <p>If you're not accustomed to F#, try not to focus too much on the syntax,  just recognize that we can return either an <code>Ok</code> or an <code>Error</code> from the  function and that's perfectly fine. In the example you will notice a few  operators called <code>Pipe</code> which look like this <code>|&gt;</code>. We will cover how  CSharp.Made.Functional includes a similar feature in later discussions.</p> <p>Using the previous database example, let's now take a look at how we can use  the <code>Result</code> type to handle cases where the return type might be <code>Ok</code> and  sometimes it might be <code>Error</code>.</p> Program.cs<pre><code>using System;\nusing Functional;\nusing static Functional.Prelude;\n\n\nnamespace ScratchPad;\n\npublic record NotFoundError(string Message);\n\npublic static class Program\n{\n\n    // Let's use random to decide if finding the string succeeded or not.\n    // Imagine this is a database call or some other error prone operation.\n    public static Option&lt;string&gt; TryFindString(string input) =&gt;\n        (new Random().Next(2) == 1) switch\n        {\n            true =&gt; Some(input),\n            false =&gt; None&lt;string&gt;()\n        };\n\n    public static Result&lt;string, NotFoundError&gt; StringFindingService(string input) =&gt;\n        TryFindString(input)\n            .Map(Ok&lt;string, NotFoundError&gt;)\n            .Reduce(() =&gt;\n                new NotFoundError($\"'{input}' was not found.\")\n                    .Pipe(Error&lt;string, NotFoundError&gt;));\n    public static void Main()\n    {\n        for (var i = 0; i &lt; 10; i++)\n        {\n            var result =\n                StringFindingService(\"Hello, Results!\")\n                    .Reduce(error =&gt; error.Message);\n\n            Console.WriteLine(result);\n        }\n    }\n}\n</code></pre> <p>The example shows how we can use <code>Ok</code> and <code>Error</code> to return a  <code>Result</code> type. In C#, we need to be a little bit more explicit about the  types to make the compiler happy, so this is why the example is using  <code>Ok&lt;string, NotFoundError&gt;</code> where in F# that wouldn't be needed. Astute  observers would also notice that there are similar methods on <code>Result</code> as  there are on <code>Option</code>, which is quite on purpose. The aim of this library  is to be consistent and easy to use. It will feel much more natural to reach  for <code>Match</code>, <code>Map</code>, and <code>Reduce</code> when they're used for multiple types throughout  the library.</p>"},{"location":"Examples/#ok-and-error","title":"Ok and Error","text":"<p>To create a <code>Result</code> that is either <code>Ok</code> or <code>Error</code>, simply use the convenience  methods on the <code>Prelude</code> class. As shown below, the type signatures can get quite  long sometimes. In most cases I prefer to use <code>var</code> instead of the specific type,  but for clarity I have shown them here. In the example below, I have created  a simple <code>NotFoundError</code> type, but using what was discussed in the <code>Union</code>  section, this could also easily be a <code>Union</code> type with multiple error variants.  This is where the <code>Result</code> type really shines.</p> Program.cs<pre><code>using Functional.Results;\n\nnamespace ScratchPad;\n\npublic record NotFoundError(string Message);\n\npublic static class Program\n{\n    public static void Main()\n    {\n        Result&lt;string, NotFoundError&gt; ok = Ok&lt;string, NotFoundError&gt;(\"It's okay\");\n        Result&lt;string, NotFoundError&gt; error = \n            Error&lt;string, NotFoundError&gt;(new NotFoundError(\"An error message\"));\n    }\n}\n</code></pre>"},{"location":"Examples/#map-and-reduce","title":"Map and Reduce","text":"<p>Just like the <code>Option</code> type, <code>Result</code> has <code>Map</code> and <code>Reduce</code> methods. <code>Map</code> works exactly the same way, in that if the <code>Result</code> is <code>Ok</code>, then it performs  the mapping function on the inner contents. <code>Reduce</code>, however has multiple  overloaded methods. It can be used in a way that discards the error and returns  an alternate value, or it can use the error to then create the alternate value.</p> <p>The <code>Map</code> function can be called multiple times to perform different  transformations therefore pipelining the values from the previous transformation  to the next one. This can greatly improve the readability of what is happening to  a value as it goes through the pipeline. The example below is contrived in that  you could perform the mapping steps all in one operation, but for the sake of  demonstration, it's been broken out into multiple <code>Map</code> operations.</p> <p><code>TryPayForMovies</code> returns a <code>Result&lt;int, InsufficientFundsError&gt;</code> which for our  purposes means that sometimes the balance is <code>Ok</code> and sometimes, usually  according to some business or domain logic, it could be an <code>Error</code>. Through  multiple <code>Map</code> steps, we can convert the number to a string, add a <code>$</code>, then  add some more formatting for readability through the power of composition. To  demonstrate various cases, the example uses <code>Enumerable.Range</code> to print  different results 10 times.</p> Program.cs<pre><code>using System;\nusing System.Linq;\nusing Functional;\nusing static Functional.Prelude;\n\nnamespace ScratchPad;\n\npublic record InsufficientFundsError(string Message);\n\npublic static class Program\n{\n    public static Result&lt;int, InsufficientFundsError&gt; TryPayForMovies() =&gt;\n        // Let's assume that movies cost $25\n        new Random().Next(100) switch\n        {\n            var balance when balance &gt; 25 =&gt;\n                (balance - 25)\n                    .Pipe(Ok&lt;int, InsufficientFundsError&gt;),\n            var balance =&gt;\n                new InsufficientFundsError($\"Movie Error: balance of ${balance} is too low to pay for movies.\")\n                    .Pipe(Error&lt;int, InsufficientFundsError&gt;)\n        };\n    public static void Main() =&gt;\n        Enumerable\n            .Range(0, 30)\n            .ToList()\n            .ForEach(_ =&gt;\n                TryPayForMovies()\n                    .Map(balance =&gt; balance.ToString())\n                    .Map(strBalance =&gt; $\"${strBalance}\")\n                    .Map(withDollarSign =&gt; $\"Your balance after paying for the movies: {withDollarSign}\")\n                    .Reduce(err =&gt; err.Message)\n                    .Tap(Console.WriteLine)\n                    .Ignore());\n}\n</code></pre>"},{"location":"Examples/#map-errors","title":"Map Errors","text":"<p>In some cases, it will be necessary to convert one error type to another, just like when performing a regular mapping function. In this case, reach  for the <code>MapError</code> method.</p> Program.cs<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Functional;\nusing static Functional.Prelude;\n\nnamespace ScratchPad;\n\npublic record InsufficientFundsError(string Message);\n\npublic record ApplicationError(List&lt;string&gt; Errors);\n\npublic static class Program\n{\n    public static Result&lt;int, InsufficientFundsError&gt; TryPayForMovies() =&gt;\n        // Let's assume that movies cost $25\n        new Random().Next(100) switch\n        {\n            var balance when balance &gt; 25 =&gt;\n                (balance - 25)\n                    .Pipe(Ok&lt;int, InsufficientFundsError&gt;),\n            var balance =&gt;\n                new InsufficientFundsError($\"Movie Error: balance of ${balance} is too low to pay for movies.\")\n                    .Pipe(Error&lt;int, InsufficientFundsError&gt;)\n        };\n\n    public static void PrintErrorMessages(this Result&lt;string, ApplicationError&gt; result)\n    {\n        result\n            .Effect(\n                ok =&gt; { },\n                err =&gt; err.Errors.ForEach(Console.WriteLine)\n            );\n    }\n\n    public static ApplicationError ToApplicationError(this InsufficientFundsError error)\n    {\n        var errorMessage = error.Message;\n        var errorList = new List&lt;string&gt; { errorMessage };\n        return new ApplicationError(errorList);\n    }\n\n    public static void Main() =&gt;\n        Enumerable\n            .Range(0, 30)\n            .ToList()\n            .ForEach(_ =&gt;\n                TryPayForMovies()\n                    .Map(balance =&gt; balance.ToString())\n                    .Map(strBalance =&gt; $\"${strBalance}\")\n                    .Map(withDollarSign =&gt; $\"Your balance after paying for the movies: {withDollarSign}\")\n                    .MapError(err =&gt; err.ToApplicationError())\n                    .Tap(err =&gt; err.PrintErrorMessages())\n                    .Ignore());\n}\n</code></pre>"},{"location":"Examples/#result-match","title":"Result Match","text":"<p>The previous example can be rewritten using <code>Match</code> as well. However, as previously  noted, <code>Map</code> can be called many times, where <code>Match</code> can only be called once.  <code>Match</code> should be thought of as a replacement for a single <code>Map</code> and <code>Reduce</code> operation. This way, if there are many <code>Map</code> operations to perform, it is possible to do all of them except the last one, then call <code>Match</code>.</p> Program.cs<pre><code>using System;\nusing System.Linq;\nusing Functional;\nusing static Functional.Prelude;\n\nnamespace ScratchPad;\n\npublic record InsufficientFundsError(string Message);\n\npublic static class Program\n{\n    public static Result&lt;int, InsufficientFundsError&gt; TryPayForMovies() =&gt;\n        // Let's assume that movies cost $25\n        new Random().Next(100) switch\n        {\n            var balance when balance &gt; 25 =&gt;\n                (balance - 25)\n                    .Pipe(Ok&lt;int, InsufficientFundsError&gt;),\n            var balance =&gt;\n                new InsufficientFundsError($\"Movie Error: balance of ${balance} is too low to pay for movies.\")\n                    .Pipe(Error&lt;int, InsufficientFundsError&gt;)\n        };\n\n    public static void Main() =&gt;\n        Enumerable\n            .Range(0, 30)\n            .ToList()\n            .ForEach(_ =&gt;\n                TryPayForMovies()\n                    .Map(balance =&gt; balance.ToString())\n                    .Map(strBalance =&gt; $\"${strBalance}\")\n                    .Match(\n                        withDollarSign =&gt; $\"Your balance after paying for the movies: {withDollarSign}\",\n                        err =&gt; err.Message)\n                    .Tap(Console.WriteLine)\n                    .Ignore());\n}\n</code></pre>"},{"location":"Examples/#result-bind","title":"Result Bind","text":"<p>Just like the <code>Bind</code> method for <code>Option</code>, <code>Result</code> also has a <code>Bind</code> method for  when a mapping operation produces another <code>Result</code> type. There is a current  limitation on this method where the binding method must also produce the same  error type. This usually isn't a problem, but something to be aware of. Much of  this limitation can be overcome by using Discriminated Unions for an error type.  This way, a binding method could produce a different error perhaps, but if it's a  variant of a discriminated union, C# will still see it as the parent discriminated union type. In the following example, let's say that we wanted to pay for a movie  and buy dinner. Buying dinner though, depends on whether or not there was money  left over after paying for the movies.</p> Program.cs<pre><code>using System;\nusing System.Linq;\nusing Functional;\nusing static Functional.Prelude;\n\nnamespace ScratchPad;\n\npublic record InsufficientFundsError(string Message);\n\npublic static class Program\n{\n    public static Result&lt;int, InsufficientFundsError&gt; TryPayForMovies() =&gt;\n        // Let's assume that movies cost $25\n        new Random().Next(100) switch\n        {\n            var balance when balance &gt; 25 =&gt;\n                (balance - 25)\n                    .Pipe(Ok&lt;int, InsufficientFundsError&gt;),\n            var balance =&gt;\n                new InsufficientFundsError($\"Movie Error: balance of ${balance} is too low to pay for movies.\")\n                    .Pipe(Error&lt;int, InsufficientFundsError&gt;)\n        };\n\n    public static Result&lt;int, InsufficientFundsError&gt; TryBuyDinner(int balance) =&gt;\n        // assuming dinner costs $50\n        balance switch {\n            var bal when bal &gt;= 50 =&gt;\n                (balance - 50)\n                    .Pipe(Ok&lt;int, InsufficientFundsError&gt;),\n            _ =&gt; \n                new InsufficientFundsError($\"Dinner Error: balance of ${balance} was too low to pay for dinner.\")\n                    .Pipe(Error&lt;int, InsufficientFundsError&gt;)\n        };\n\n\n    public static void Main() =&gt;\n        Enumerable\n            .Range(0, 30)\n            .ToList()\n            .ForEach(_ =&gt;\n                TryPayForMovies()\n                    .Bind(TryBuyDinner)\n                    .Map(balance =&gt; balance.ToString())\n                    .Map(strBalance =&gt; $\"${strBalance}\")\n                    .Map(withDollarSign =&gt; $\"Your balance after paying for the movies: {withDollarSign}\")\n                    .Reduce(err =&gt; err.Message)\n                    .Tap(Console.WriteLine)\n                    .Ignore());\n}\n</code></pre>"},{"location":"Examples/#result-effect","title":"Result Effect","text":"<p>Just like <code>Option</code> and <code>Union</code>, <code>Result</code> also has an <code>Effect</code> method that  allows us to perform some <code>Action</code> which returns <code>void</code> as a side-effect on  our <code>Result</code> type. <code>Effect</code> is similar to <code>Match</code>, but instead of returning  value, both arms return <code>void</code>. We can use <code>Effect</code> in place of the <code>Map</code>,  <code>Reduce</code>, and <code>Tap</code> methods used in the previous example.</p> Program.cs<pre><code>using System;\nusing System.Linq;\nusing Functional;\nusing static Functional.Prelude;\n\nnamespace ScratchPad;\n\npublic record InsufficientFundsError(string Message);\n\npublic static class Program\n{\n    public static Result&lt;int, InsufficientFundsError&gt; TryPayForMovies() =&gt;\n        // Let's assume that movies cost $25\n        new Random().Next(100) switch\n        {\n            var balance when balance &gt; 25 =&gt;\n                (balance - 25)\n                    .Pipe(Ok&lt;int, InsufficientFundsError&gt;),\n            var balance =&gt;\n                new InsufficientFundsError($\"Movie Error: balance of ${balance} is too low to pay for movies.\")\n                    .Pipe(Error&lt;int, InsufficientFundsError&gt;)\n        };\n\n    public static Result&lt;int, InsufficientFundsError&gt; TryBuyDinner(int balance) =&gt;\n        // assuming dinner costs $50\n        balance switch\n        {\n            var bal when bal &gt;= 50 =&gt;\n                (balance - 50)\n                    .Pipe(Ok&lt;int, InsufficientFundsError&gt;),\n            _ =&gt;\n                new InsufficientFundsError($\"Dinner Error: balance of ${balance} was too low to pay for dinner.\")\n                    .Pipe(Error&lt;int, InsufficientFundsError&gt;)\n        };\n\n    public static void Main() =&gt;\n        Enumerable\n            .Range(0, 30)\n            .ToList()\n            .ForEach(_ =&gt;\n                TryPayForMovies()\n                    .Bind(TryBuyDinner)\n                    .Map(balance =&gt; balance.ToString())\n                    .Map(strBalance =&gt; $\"${strBalance}\")\n                    .Effect(\n                        withDollarSign =&gt;\n                            Console.WriteLine($\"Your balance after paying for dinner and the movies: {withDollarSign}\"),\n                        err =&gt; Console.WriteLine(err.Message)));\n}\n</code></pre>"},{"location":"Examples/#result-effectok-and-effecterror","title":"Result EffectOk and EffectError","text":"<p>Perform an <code>Effect</code> when a <code>Result</code> is <code>Ok</code> or when it is an <code>Error</code>.</p> Program.cs<pre><code>namespace ScratchPad;\n\nusing Functional;\nusing static Functional.Prelude;\nusing System;\n\npublic static class Program\n{\n    public static void Main()\n    {\n        // This will print \"value\" to the console.\n        Ok(\"value\")\n            .EffectOk(value =&gt; Console.WriteLine(value));\n\n        // This will do nothing since the input value was an Error.\n        Error&lt;string&gt;(new Exception(\"Something bad happened\"))\n            .EffectOk(value =&gt; Console.WriteLine(value));\n\n        // This will do nothing since the input value is Ok\n        Ok(\"value\")\n            .EffectError(exception =&gt; Console.WriteLine(exception.Message));\n\n        // This will print \"Something bad happened\" since it was an error.\n        Error&lt;string&gt;(new Exception(\"Something bad happened\"))\n            .EffectError(exception =&gt; Console.WriteLine(exception.Message));\n    }\n}\n</code></pre>"},{"location":"Examples/#result-tap-tapok-and-taperror","title":"Result Tap, TapOk, and TapError","text":"<p>If we want to <code>Tap</code> into the <code>Result</code> and perform some effect without consuming the value, we can use <code>Tap</code>, <code>TapOk</code>, and <code>TapError</code>. With <code>Tap</code>, some kind of action must be provided for both the <code>Ok</code> and <code>Error</code> cases.</p> <p>For <code>TapOk</code> and <code>TapError</code>, one or more actions can be provided to occur when the <code>Result</code> meets that criteria. This will allow us to only perform actions when the value is <code>Ok</code> or <code>Error</code> for instance.</p> Program.cs<pre><code>namespace ScratchPad;\n\nusing Functional;\nusing static Functional.Prelude;\nusing System;\n\npublic static class Program\n{\n    public static void Main()\n    {\n        // Actions can be performed when ok and error.\n        Ok(\"value\")\n            .Tap(ok =&gt; Console.WriteLine(ok), exception =&gt; Console.WriteLine(exception.Message))\n            // The Result is not consumed so we can still use it afterwards.\n            .Map(ok =&gt; ok + \"!\");\n\n        // We can do multiple things when the value is Ok with a TapOk.\n        string? temp = null;\n        Ok(\"value\")\n            .TapOk(\n                value =&gt; Console.WriteLine(value),\n                value =&gt; temp = value);\n\n        // Nothing happens here since the value is an error.\n        // Error&lt;T&gt; creates a Result&lt;T, Exception&gt; by accepting a string or an Exception.\n        // The value \"Error!\" is used as the exception message.\n        Error&lt;string&gt;(\"Error!\")\n            .TapOk(value =&gt; Console.WriteLine(value));\n    }\n}\n</code></pre>"},{"location":"Examples/#result-unwrap-and-unwraperror","title":"Result Unwrap and UnwrapError","text":"<p>If we need to get the value out of a <code>Result</code> for some reason and it's impractical to use <code>Match</code>, <code>Map</code>, <code>Tap</code>, or <code>Effect</code>, we can <code>Unwrap</code> or <code>UnwrapError</code> in order to get its inner contents. It's vital to check to see if the <code>Result</code> is <code>Ok</code> before using <code>Unwrap</code> and see if it's <code>Error</code> before using <code>UnwrapError</code>, otherwise it will throw an exception!</p> Program.cs<pre><code>namespace ScratchPad;\nusing static Functional.Prelude;\nusing Functional;\n\npublic static class Program\n{\n    public static void Main()\n    {\n        // This will unwrap fine because the value is Ok.\n        string value = Ok(\"value\").Unwrap();\n\n        // This will throw an exception because the value is an error.\n        string never = Error&lt;string&gt;(\"Error!\").Unwrap();\n\n        // To do this safely, we need to always check the Option first!\n        var result = Error&lt;string&gt;(\"Error!\");\n        if (result.IsOk)\n        {\n            value = result.Unwrap();\n        }\n        if (result.IsError)\n        {\n            value = result.UnwrapError().Message;\n        }\n    }\n}\n</code></pre>"},{"location":"Examples/#async-results","title":"Async Results","text":"<p>Asynchronous support is also provided in this library for <code>Result</code>.</p> <p>Included async methods:</p> <ul> <li><code>MapAsync</code></li> <li><code>ReduceAsync</code></li> <li><code>MatchAsync</code></li> <li><code>BindAsync</code></li> <li><code>EffectAsync</code></li> <li><code>EffectOkAsync</code></li> <li><code>EffectErrorAsync</code></li> <li><code>TapAsync</code></li> <li><code>TapOkAsync</code></li> <li><code>TapErrorAsync</code></li> <li><code>UnwrapAsync</code></li> <li><code>UnwrapErrorAsync</code></li> </ul> Program.cs<pre><code>using System;\nusing System.Threading.Tasks;\nusing Functional;\nusing static Functional.Prelude;\n\nnamespace ScratchPad;\n\npublic record CustomError(string Message);\n\npublic static class Program\n{\n    public static async Task Main() =&gt;\n        await Ok&lt;string, CustomError&gt;(\"Ok\")\n            .Async()\n            .MapAsync(ok =&gt; ok + \"!\")\n            .EffectAsync(\n                ok =&gt; Console.WriteLine(ok),\n                err =&gt; Console.WriteLine(err.Message));\n}\n</code></pre>"},{"location":"Examples/#common-extensions","title":"Common Extensions","text":"<p>Throughout these examples, there have been a few extension methods that have  made functional programming easier to work with in C#. Let's talk about a few  of those in detail now.</p>"},{"location":"Examples/#pipe","title":"Pipe","text":"<p><code>Pipe</code> is a general-purpose mapping function that works with any type. Due to  limitations and naming conflicts in C#, using <code>Map</code> again for this purpose  was not possible. Because of this, I chose to use the name <code>Pipe</code> to match the F# <code>|&gt;</code> pipe operator. Pipe allows us to take the results of a previous function,  transformation, or other expression and then perform additional transformations on it. Here is a simple example demonstrating its use. There is also a  <code>PipeAsync</code> method for async processing as well.</p> Program.cs<pre><code>using System;\nusing Functional;\nusing static Functional.Prelude;\nnamespace ScratchPad;\n\npublic record CustomError(string Message);\n\npublic static class Program\n{\n    public static int OneMillion =&gt; 1_000_000;\n\n    public static void Main() =&gt;\n        OneMillion\n            .Pipe(money =&gt; string.Format(\"{0:C}\", money))\n            .Tap(Console.WriteLine)\n            .Ignore();\n}\n</code></pre>"},{"location":"Examples/#tap","title":"Tap","text":"<p>In the previous example, we used the <code>Tap</code> method to perform a side-effect  the output of the <code>Pipe</code> method. The way that <code>Tap</code> works, is that it will  perform operations on the output of the previous value, and then return that  value as its output. For immutable types, the output will be unchanged. However, be warned that if the action performed in the <code>Tap</code> method mutates the input,  then the output will also have mutated values. Below is an example with a mutable  property to demonstrate this behavior. There is also a <code>TapAsync</code> method for  async processing as well.</p> Program.cs<pre><code>using System;\nusing Functional;\nusing static Functional.Prelude;\nnamespace ScratchPad;\n\npublic class IntClass\n{\n    public int Value { get; set; }\n}\n\npublic static class Program\n{\n    public static int OneMillion =&gt; 1_000_000;\n\n    public static void Main()\n    {\n        var classValue =\n            OneMillion\n                .Pipe(number =&gt; new IntClass { Value = number })\n                .Tap(intClass =&gt; intClass.Value += 1)\n                .Pipe(intClass =&gt; intClass.Value);\n\n        // Prints \"1000001\" because the class value was mutated.\n        Console.WriteLine(classValue);\n    }\n\n}\n</code></pre> <p><code>Tap</code> allows multiple actions to provided so that many things can be done to  the input at once. Here is an example demonstrating adding 1 and then printing the results before saving the value in a variable.</p> Program.cs<pre><code>using System;\nusing Functional;\nusing static Functional.Prelude;\nnamespace ScratchPad;\n\npublic class IntClass\n{\n    public int Value { get; set; }\n}\n\npublic static class Program\n{\n    public static int OneMillion =&gt; 1_000_000;\n\n    public static void Main()\n    {\n        var classValue =\n            OneMillion\n                .Pipe(number =&gt; new IntClass { Value = number })\n                .Tap(\n                    intClass =&gt; intClass.Value += 1,\n                    intClass =&gt; Console.WriteLine($\"Printed In Tap: {intClass.Value}\"))\n                .Pipe(intClass =&gt; intClass.Value);\n\n        // Prints \"1000001\" because the class value was mutated.\n        Console.WriteLine($\"Printed at the end: {classValue}\");\n    }\n}\n</code></pre>"},{"location":"Examples/#effect","title":"Effect","text":"<p><code>Effect</code> is like a <code>Pipe</code> that consumes the input, performs some series  of actions, and returns <code>Unit</code>.</p> Program.cs<pre><code>namespace ScratchPad;\n\nusing Functional;\n\nusing System;\n\nusing static Functional.Prelude;\n\npublic static class Program\n{\n    public static void Main()\n    {\n        \"Some Random Value\"\n            .Effect(input =&gt; Console.WriteLine(input));\n\n        Effect(() =&gt; Console.WriteLine(\"another way.\"))\n            .Pipe(unit =&gt; \"It's a unit type!\");\n\n        EffectAsync(() =&gt; Console.WriteLine(\"This one returns a Task&lt;Unit&gt;!\"))\n            .PipeAsync(unit =&gt; \"It's another unit!\");\n    }\n}\n</code></pre>"},{"location":"Examples/#cons","title":"Cons","text":"<p><code>Cons</code> generates an <code>ImmutableList</code> of any type that you put in it. In .NET 8 and C# 12, Collection Expressions and Collection Literals help reduce the  need for this, but it can still be useful in older versions. See example  below for usage.</p> Program.cs<pre><code>using System;\nusing static Functional.Common.CommonExtensions;\n\nnamespace ScratchPad;\n\npublic static class Program\n{\n    public static void Main()\n    {\n        Cons(\"some\", \"things\", \"to\", \"print\")\n            .ForEach(Console.WriteLine);\n    }\n}\n</code></pre>"},{"location":"Examples/#ignore","title":"Ignore","text":"<p><code>Ignore</code> and <code>IgnoreAsync</code> are used to ignore the output of a function. In languages like F#, any unused values must be explicitly ignored. In C#, this isn't required. To indicate that a calculated result is ignored, you can add this to the end of the function. <code>Ignore</code> produces <code>void</code> and <code>IgnoreAsync</code> produces a <code>Task</code>.</p> Program.cs<pre><code>using System.Threading.Tasks;\nusing static Functional.Common.CommonExtensions;\n\nnamespace ScratchPad;\n\npublic static class Program\n{\n    public static async Task Main()\n    {\n        \"Some Contents\"\n            .Pipe(str =&gt; str + \"!\")\n            .Ignore();\n\n        await \"Some Async Contents\"\n            .Async()\n            .PipeAsync(str =&gt; str + \"!\")\n            .IgnoreAsync();\n    }\n}\n</code></pre>"},{"location":"Examples/#exception-handling","title":"Exception Handling","text":"<p>When interacting with code that can throw Exceptions, we normally reach for the  traditional <code>Try/Catch/Finally</code> block. CSharp.Made.Functional includes a few  methods to deal with exceptions in a more fluent style.</p>"},{"location":"Examples/#try","title":"Try","text":"<p>Use <code>Try</code> to perform an operation which could throw an Exception. There are two  variants to this method. First, it can be used as a plain static method  which expects some function to be performed that returns some kind of value.  There is also an extension method that allows a previous value to be used as  input to <code>Try</code> which is shown in a later example. The return type of these  methods is <code>Result&lt;TResult, Exception&gt;</code> where <code>TResult</code> is the type that the  operation returns. Since there are already a lot of useful methods available  on <code>Result</code>, it makes working with basic <code>Try/Catch</code> work simpler.  CSharp.Made.Functional does not provide any mechanisms for a <code>Finally</code>  block and it's recommended to use the standard <code>Try/Catch/Finally</code> approach in  those cases. Since overly broad Exception catching is not a best practice,  it is recommended to use a <code>Switch Expression</code> when matching on the <code>Result</code>  to handle specific exceptions that are expected for this operation.</p> <p>In the example below, since we think it could throw, we want to use  the <code>Result</code> type to help us determine if it was <code>Ok</code> or an <code>Error</code>. We can make decisions in the <code>Catch</code> handler as to whether or not we want to return  an <code>Error</code> or we can also throw if it truly is a catastrophic exception.</p> <p>Like all of the other methods in this library, there are also async methods  which work the same way.</p> Program.cs<pre><code>using System;\nusing Functional;\nusing static Functional.Prelude;\n\nnamespace ScratchPad;\n\npublic record CustomError(string Message);\n\npublic static class Program\n{\n    public static int ItMightThrow() =&gt;\n        new Random().Next(100) switch\n        {\n            var value when value &gt; 50 =&gt; value,\n            var value =&gt; throw new Exception($\"Value was {value}\")\n        };\n\n    public static void Main() =&gt; \n        Try(ItMightThrow)\n            .Match(\n                ok =&gt; ok.Pipe(Result.Ok&lt;int, CustomError&gt;),\n                exception =&gt;\n                {\n                    // Example logging.\n                    Console.WriteLine(exception.Message);\n                    exception\n                        .InnerExceptionMessage()\n                        .Effect(\n                            err =&gt; Console.WriteLine(err),\n                            () =&gt; { /* It was none, don't print anything. */ });\n\n                    return (exception switch\n                    {\n                        ArgumentNullException =&gt; \"It was null\",\n                        OperationCanceledException =&gt; \"It was cancelled\",\n                        _ =&gt; \"We don't know why it crashed...\"\n                    })\n                    .Pipe(msg =&gt; new CustomError(msg))\n                    .Pipe(Result.Error&lt;int, CustomError&gt;);\n                })\n            .Match(ok =&gt; ok.ToString(), err =&gt; err.Message)\n            .Tap(Console.WriteLine)\n            .Ignore();\n}\n</code></pre> <p><code>Try</code> can also be used as an extension method in order to add a <code>Try/Catch</code>  handler to the end of a function that isn't expected to throw.</p> Program.cs<pre><code>using System;\nusing Functional;\nusing static Functional.Prelude;\n\nnamespace ScratchPad;\n\npublic record CustomError(string Message);\n\npublic static class Program\n{\n    public static int ItNeverThrows() =&gt;\n        new Random().Next(100);\n\n    public static int ItMightThrow(int input) =&gt;\n        input switch\n        {\n            var value when value &gt; 50 =&gt; value,\n            var value =&gt; throw new Exception($\"Value was {value}\")\n        };\n\n    public static void Main() =&gt;\n        ItNeverThrows()\n            .Try(ItMightThrow)\n            .Match(\n                ok =&gt; ok.Pipe(Result.Ok&lt;int, CustomError&gt;),\n                exception =&gt;\n                {\n                    // Example logging.\n                    Console.WriteLine(exception.Message);\n                    exception\n                        .InnerExceptionMessage()\n                        .Effect(\n                            err =&gt; Console.WriteLine(err),\n                            () =&gt; { /* It was none, don't print anything. */ });\n\n                    return (exception switch\n                    {\n                        ArgumentNullException =&gt; \"It was null\",\n                        OperationCanceledException =&gt; \"It was cancelled\",\n                        _ =&gt; \"We don't know why it crashed...\"\n                    })\n                    .Pipe(msg =&gt; new CustomError(msg))\n                    .Pipe(Result.Error&lt;int, CustomError&gt;);\n                })\n            .Match(\n                ok =&gt; ok.ToString(),\n                err =&gt; err.Message)\n            .Tap(Console.WriteLine)\n            .Ignore();\n}\n</code></pre>"},{"location":"Examples/#inner-exception-messages","title":"Inner Exception Messages","text":"<p>Exceptions may or may not have an inner exception message. There is a convenience method called <code>InnerExceptionMessage()</code> which returns <code>Option&lt;string&gt;</code> to safely handle getting an inner exception method.</p> Program.cs<pre><code>using System;\nusing Functional;\nusing static Functional.Prelude;\n\nnamespace ScratchPad;\n\npublic record CustomError(string Message);\n\npublic static class Program\n{\n    public static void Main()\n    {\n        new Exception(\"outer message\", new Exception(\"Inner message\"))\n            .InnerExceptionMessage()\n            .Effect(\n                // This will print because there is an inner exception.\n                Console.WriteLine,\n                () =&gt; { /* There was no inner exception */ });\n\n        // Nothing will print here because there was no inner exception.\n        new Exception(\"outer message\")\n            .InnerExceptionMessage()\n            .Effect(\n                Console.WriteLine,\n                () =&gt; { /* There was no inner exception */ });\n    }\n}\n</code></pre>"},{"location":"Examples/#unit","title":"Unit","text":"<p>When performing an action, instead of returning void, we can return the type called <code>Unit</code> which represents no return value. This can be used to continue piping more functions after performing an action that would return void. Calling the second <code>Effect</code> would not have been possible without the <code>Unit</code> type.</p> Program.cs<pre><code>namespace ScratchPad;\n\nusing Functional;\nusing static Functional.Prelude;\n\nusing System;\n\npublic static class Program\n{\n    public static void Main()\n    {\n        // This should print \"value\" and then \"()\" on the following line.\n        Some(\"value\")\n            .Effect(value =&gt; Console.WriteLine(value), () =&gt; Console.WriteLine(\"No value\"))\n            .Effect(unit =&gt; Console.WriteLine(unit.ToString()));\n    }\n}\n</code></pre>"},{"location":"GettingStarted/","title":"Getting Started","text":""},{"location":"GettingStarted/#add-csharpmadefunctional","title":"Add CSharp.Made.Functional","text":"Command Line<pre><code>dotnet add package CSharp.Made.Functional\n</code></pre>"},{"location":"GettingStarted/#using-statements","title":"Using statements","text":"<p>The namespace does not match the package name to keep using statements shorter.</p> Usings.cs<pre><code>// Required Usings\n\nglobal using Functional;\nglobal using static Functional.Prelude;\n</code></pre>"}]}